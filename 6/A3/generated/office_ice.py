# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.3
#
# <auto-generated>
#
# Generated from file `office.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module Office
_M_Office = Ice.openModule('Office')
__name__ = 'Office'

if 'TaskType' not in _M_Office.__dict__:
    _M_Office.TaskType = Ice.createTempClass()
    class TaskType(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    TaskType.RECEIVENEWID = TaskType("RECEIVENEWID", 0)
    TaskType.CARREGISTRATION = TaskType("CARREGISTRATION", 1)
    TaskType.SENDTAX = TaskType("SENDTAX", 2)
    TaskType._enumerators = { 0:TaskType.RECEIVENEWID, 1:TaskType.CARREGISTRATION, 2:TaskType.SENDTAX }

    _M_Office._t_TaskType = IcePy.defineEnum('::Office::TaskType', TaskType, (), TaskType._enumerators)

    _M_Office.TaskType = TaskType
    del TaskType

if 'Status' not in _M_Office.__dict__:
    _M_Office.Status = Ice.createTempClass()
    class Status(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Status.RECEIVED = Status("RECEIVED", 0)
    Status.PROCESSED = Status("PROCESSED", 1)
    Status.DONE = Status("DONE", 2)
    Status.ERROR = Status("ERROR", 3)
    Status._enumerators = { 0:Status.RECEIVED, 1:Status.PROCESSED, 2:Status.DONE, 3:Status.ERROR }

    _M_Office._t_Status = IcePy.defineEnum('::Office::Status', Status, (), Status._enumerators)

    _M_Office.Status = Status
    del Status

if 'Task' not in _M_Office.__dict__:
    _M_Office.Task = Ice.createTempClass()
    class Task(Ice.Value):
        def __init__(self, taskType=_M_Office.TaskType.RECEIVENEWID, id=0, time=Ice.Unset, status=_M_Office.Status.RECEIVED):
            self.taskType = taskType
            self.id = id
            self.time = time
            self.status = status

        def ice_id(self):
            return '::Office::Task'

        @staticmethod
        def ice_staticId():
            return '::Office::Task'

        def __str__(self):
            return IcePy.stringify(self, _M_Office._t_Task)

        __repr__ = __str__

    _M_Office._t_Task = IcePy.defineValue('::Office::Task', Task, -1, (), False, False, None, (
        ('taskType', (), _M_Office._t_TaskType, False, 0),
        ('id', (), IcePy._t_long, False, 0),
        ('time', (), IcePy._t_int, True, 1),
        ('status', (), _M_Office._t_Status, False, 0)
    ))
    Task._ice_type = _M_Office._t_Task

    _M_Office.Task = Task
    del Task

if 'Account' not in _M_Office.__dict__:
    _M_Office.Account = Ice.createTempClass()
    class Account(object):
        def __init__(self, id=0, name=''):
            self.id = id
            self.name = name

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.id)
            _h = 5 * _h + Ice.getHash(self.name)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Office.Account):
                return NotImplemented
            else:
                if self.id is None or other.id is None:
                    if self.id != other.id:
                        return (-1 if self.id is None else 1)
                else:
                    if self.id < other.id:
                        return -1
                    elif self.id > other.id:
                        return 1
                if self.name is None or other.name is None:
                    if self.name != other.name:
                        return (-1 if self.name is None else 1)
                else:
                    if self.name < other.name:
                        return -1
                    elif self.name > other.name:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Office._t_Account)

        __repr__ = __str__

    _M_Office._t_Account = IcePy.defineStruct('::Office::Account', Account, (), (
        ('id', (), IcePy._t_long),
        ('name', (), IcePy._t_string)
    ))

    _M_Office.Account = Account
    del Account

if '_t_Tasks' not in _M_Office.__dict__:
    _M_Office._t_Tasks = IcePy.defineSequence('::Office::Tasks', (), _M_Office._t_Task)

if 'UserAlreadyExists' not in _M_Office.__dict__:
    _M_Office.UserAlreadyExists = Ice.createTempClass()
    class UserAlreadyExists(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Office::UserAlreadyExists'

    _M_Office._t_UserAlreadyExists = IcePy.defineException('::Office::UserAlreadyExists', UserAlreadyExists, (), False, None, ())
    UserAlreadyExists._ice_type = _M_Office._t_UserAlreadyExists

    _M_Office.UserAlreadyExists = UserAlreadyExists
    del UserAlreadyExists

if 'UserNotExists' not in _M_Office.__dict__:
    _M_Office.UserNotExists = Ice.createTempClass()
    class UserNotExists(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Office::UserNotExists'

    _M_Office._t_UserNotExists = IcePy.defineException('::Office::UserNotExists', UserNotExists, (), False, None, ())
    UserNotExists._ice_type = _M_Office._t_UserNotExists

    _M_Office.UserNotExists = UserNotExists
    del UserNotExists

if 'TaskProccessingException' not in _M_Office.__dict__:
    _M_Office.TaskProccessingException = Ice.createTempClass()
    class TaskProccessingException(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Office::TaskProccessingException'

    _M_Office._t_TaskProccessingException = IcePy.defineException('::Office::TaskProccessingException', TaskProccessingException, (), False, None, ())
    TaskProccessingException._ice_type = _M_Office._t_TaskProccessingException

    _M_Office.TaskProccessingException = TaskProccessingException
    del TaskProccessingException

_M_Office._t_ClientAccountManager = IcePy.defineValue('::Office::ClientAccountManager', Ice.Value, -1, (), False, True, None, ())

if 'ClientAccountManagerPrx' not in _M_Office.__dict__:
    _M_Office.ClientAccountManagerPrx = Ice.createTempClass()
    class ClientAccountManagerPrx(Ice.ObjectPrx):

        def createTask(self, account, taskType, context=None):
            return _M_Office.ClientAccountManager._op_createTask.invoke(self, ((account, taskType), context))

        def createTaskAsync(self, account, taskType, context=None):
            return _M_Office.ClientAccountManager._op_createTask.invokeAsync(self, ((account, taskType), context))

        def begin_createTask(self, account, taskType, _response=None, _ex=None, _sent=None, context=None):
            return _M_Office.ClientAccountManager._op_createTask.begin(self, ((account, taskType), _response, _ex, _sent, context))

        def end_createTask(self, _r):
            return _M_Office.ClientAccountManager._op_createTask.end(self, _r)

        def getStatus(self, account, context=None):
            return _M_Office.ClientAccountManager._op_getStatus.invoke(self, ((account, ), context))

        def getStatusAsync(self, account, context=None):
            return _M_Office.ClientAccountManager._op_getStatus.invokeAsync(self, ((account, ), context))

        def begin_getStatus(self, account, _response=None, _ex=None, _sent=None, context=None):
            return _M_Office.ClientAccountManager._op_getStatus.begin(self, ((account, ), _response, _ex, _sent, context))

        def end_getStatus(self, _r):
            return _M_Office.ClientAccountManager._op_getStatus.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Office.ClientAccountManagerPrx.ice_checkedCast(proxy, '::Office::ClientAccountManager', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Office.ClientAccountManagerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Office::ClientAccountManager'
    _M_Office._t_ClientAccountManagerPrx = IcePy.defineProxy('::Office::ClientAccountManager', ClientAccountManagerPrx)

    _M_Office.ClientAccountManagerPrx = ClientAccountManagerPrx
    del ClientAccountManagerPrx

    _M_Office.ClientAccountManager = Ice.createTempClass()
    class ClientAccountManager(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Office::ClientAccountManager')

        def ice_id(self, current=None):
            return '::Office::ClientAccountManager'

        @staticmethod
        def ice_staticId():
            return '::Office::ClientAccountManager'

        def createTask(self, account, taskType, current=None):
            raise NotImplementedError("servant method 'createTask' not implemented")

        def getStatus(self, account, current=None):
            raise NotImplementedError("servant method 'getStatus' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Office._t_ClientAccountManagerDisp)

        __repr__ = __str__

    _M_Office._t_ClientAccountManagerDisp = IcePy.defineClass('::Office::ClientAccountManager', ClientAccountManager, (), None, ())
    ClientAccountManager._ice_type = _M_Office._t_ClientAccountManagerDisp

    ClientAccountManager._op_createTask = IcePy.Operation('createTask', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Office._t_Account, False, 0), ((), _M_Office._t_TaskType, False, 0)), (), ((), _M_Office._t_Task, False, 0), ())
    ClientAccountManager._op_getStatus = IcePy.Operation('getStatus', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Office._t_Account, False, 0),), (), ((), _M_Office._t_Tasks, False, 0), ())

    _M_Office.ClientAccountManager = ClientAccountManager
    del ClientAccountManager

_M_Office._t_CallbackReceiver = IcePy.defineValue('::Office::CallbackReceiver', Ice.Value, -1, (), False, True, None, ())

if 'CallbackReceiverPrx' not in _M_Office.__dict__:
    _M_Office.CallbackReceiverPrx = Ice.createTempClass()
    class CallbackReceiverPrx(Ice.ObjectPrx):

        def callback(self, task, context=None):
            return _M_Office.CallbackReceiver._op_callback.invoke(self, ((task, ), context))

        def callbackAsync(self, task, context=None):
            return _M_Office.CallbackReceiver._op_callback.invokeAsync(self, ((task, ), context))

        def begin_callback(self, task, _response=None, _ex=None, _sent=None, context=None):
            return _M_Office.CallbackReceiver._op_callback.begin(self, ((task, ), _response, _ex, _sent, context))

        def end_callback(self, _r):
            return _M_Office.CallbackReceiver._op_callback.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Office.CallbackReceiverPrx.ice_checkedCast(proxy, '::Office::CallbackReceiver', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Office.CallbackReceiverPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Office::CallbackReceiver'
    _M_Office._t_CallbackReceiverPrx = IcePy.defineProxy('::Office::CallbackReceiver', CallbackReceiverPrx)

    _M_Office.CallbackReceiverPrx = CallbackReceiverPrx
    del CallbackReceiverPrx

    _M_Office.CallbackReceiver = Ice.createTempClass()
    class CallbackReceiver(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Office::CallbackReceiver')

        def ice_id(self, current=None):
            return '::Office::CallbackReceiver'

        @staticmethod
        def ice_staticId():
            return '::Office::CallbackReceiver'

        def callback(self, task, current=None):
            raise NotImplementedError("servant method 'callback' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Office._t_CallbackReceiverDisp)

        __repr__ = __str__

    _M_Office._t_CallbackReceiverDisp = IcePy.defineClass('::Office::CallbackReceiver', CallbackReceiver, (), None, ())
    CallbackReceiver._ice_type = _M_Office._t_CallbackReceiverDisp

    CallbackReceiver._op_callback = IcePy.Operation('callback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Office._t_Task, False, 0),), (), None, ())

    _M_Office.CallbackReceiver = CallbackReceiver
    del CallbackReceiver

_M_Office._t_CallbackSender = IcePy.defineValue('::Office::CallbackSender', Ice.Value, -1, (), False, True, None, ())

if 'CallbackSenderPrx' not in _M_Office.__dict__:
    _M_Office.CallbackSenderPrx = Ice.createTempClass()
    class CallbackSenderPrx(Ice.ObjectPrx):

        def disconnect(self, account, context=None):
            return _M_Office.CallbackSender._op_disconnect.invoke(self, ((account, ), context))

        def disconnectAsync(self, account, context=None):
            return _M_Office.CallbackSender._op_disconnect.invokeAsync(self, ((account, ), context))

        def begin_disconnect(self, account, _response=None, _ex=None, _sent=None, context=None):
            return _M_Office.CallbackSender._op_disconnect.begin(self, ((account, ), _response, _ex, _sent, context))

        def end_disconnect(self, _r):
            return _M_Office.CallbackSender._op_disconnect.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Office.CallbackSenderPrx.ice_checkedCast(proxy, '::Office::CallbackSender', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Office.CallbackSenderPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Office::CallbackSender'
    _M_Office._t_CallbackSenderPrx = IcePy.defineProxy('::Office::CallbackSender', CallbackSenderPrx)

    _M_Office.CallbackSenderPrx = CallbackSenderPrx
    del CallbackSenderPrx

    _M_Office.CallbackSender = Ice.createTempClass()
    class CallbackSender(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Office::CallbackSender')

        def ice_id(self, current=None):
            return '::Office::CallbackSender'

        @staticmethod
        def ice_staticId():
            return '::Office::CallbackSender'

        def disconnect(self, account, current=None):
            raise NotImplementedError("servant method 'disconnect' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Office._t_CallbackSenderDisp)

        __repr__ = __str__

    _M_Office._t_CallbackSenderDisp = IcePy.defineClass('::Office::CallbackSender', CallbackSender, (), None, ())
    CallbackSender._ice_type = _M_Office._t_CallbackSenderDisp

    CallbackSender._op_disconnect = IcePy.Operation('disconnect', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Office._t_Account, False, 0),), (), None, ())

    _M_Office.CallbackSender = CallbackSender
    del CallbackSender

_M_Office._t_AccountsManager = IcePy.defineValue('::Office::AccountsManager', Ice.Value, -1, (), False, True, None, ())

if 'AccountsManagerPrx' not in _M_Office.__dict__:
    _M_Office.AccountsManagerPrx = Ice.createTempClass()
    class AccountsManagerPrx(Ice.ObjectPrx):

        def register(self, name, callbackReceiver, context=None):
            return _M_Office.AccountsManager._op_register.invoke(self, ((name, callbackReceiver), context))

        def registerAsync(self, name, callbackReceiver, context=None):
            return _M_Office.AccountsManager._op_register.invokeAsync(self, ((name, callbackReceiver), context))

        def begin_register(self, name, callbackReceiver, _response=None, _ex=None, _sent=None, context=None):
            return _M_Office.AccountsManager._op_register.begin(self, ((name, callbackReceiver), _response, _ex, _sent, context))

        def end_register(self, _r):
            return _M_Office.AccountsManager._op_register.end(self, _r)

        def login(self, name, callbackReceiver, context=None):
            return _M_Office.AccountsManager._op_login.invoke(self, ((name, callbackReceiver), context))

        def loginAsync(self, name, callbackReceiver, context=None):
            return _M_Office.AccountsManager._op_login.invokeAsync(self, ((name, callbackReceiver), context))

        def begin_login(self, name, callbackReceiver, _response=None, _ex=None, _sent=None, context=None):
            return _M_Office.AccountsManager._op_login.begin(self, ((name, callbackReceiver), _response, _ex, _sent, context))

        def end_login(self, _r):
            return _M_Office.AccountsManager._op_login.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Office.AccountsManagerPrx.ice_checkedCast(proxy, '::Office::AccountsManager', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Office.AccountsManagerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Office::AccountsManager'
    _M_Office._t_AccountsManagerPrx = IcePy.defineProxy('::Office::AccountsManager', AccountsManagerPrx)

    _M_Office.AccountsManagerPrx = AccountsManagerPrx
    del AccountsManagerPrx

    _M_Office.AccountsManager = Ice.createTempClass()
    class AccountsManager(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Office::AccountsManager')

        def ice_id(self, current=None):
            return '::Office::AccountsManager'

        @staticmethod
        def ice_staticId():
            return '::Office::AccountsManager'

        def register(self, name, callbackReceiver, current=None):
            raise NotImplementedError("servant method 'register' not implemented")

        def login(self, name, callbackReceiver, current=None):
            raise NotImplementedError("servant method 'login' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Office._t_AccountsManagerDisp)

        __repr__ = __str__

    _M_Office._t_AccountsManagerDisp = IcePy.defineClass('::Office::AccountsManager', AccountsManager, (), None, ())
    AccountsManager._ice_type = _M_Office._t_AccountsManagerDisp

    AccountsManager._op_register = IcePy.Operation('register', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_Office._t_CallbackReceiverPrx, False, 0)), (), ((), _M_Office._t_Account, False, 0), (_M_Office._t_UserAlreadyExists,))
    AccountsManager._op_login = IcePy.Operation('login', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_Office._t_CallbackReceiverPrx, False, 0)), (), ((), _M_Office._t_Account, False, 0), (_M_Office._t_UserNotExists,))

    _M_Office.AccountsManager = AccountsManager
    del AccountsManager

if 'DeliveryReceipt' not in _M_Office.__dict__:
    _M_Office.DeliveryReceipt = Ice.createTempClass()
    class DeliveryReceipt(object):
        def __init__(self, account=Ice._struct_marker, taskId=0):
            if account is Ice._struct_marker:
                self.account = _M_Office.Account()
            else:
                self.account = account
            self.taskId = taskId

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.account)
            _h = 5 * _h + Ice.getHash(self.taskId)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Office.DeliveryReceipt):
                return NotImplemented
            else:
                if self.account is None or other.account is None:
                    if self.account != other.account:
                        return (-1 if self.account is None else 1)
                else:
                    if self.account < other.account:
                        return -1
                    elif self.account > other.account:
                        return 1
                if self.taskId is None or other.taskId is None:
                    if self.taskId != other.taskId:
                        return (-1 if self.taskId is None else 1)
                else:
                    if self.taskId < other.taskId:
                        return -1
                    elif self.taskId > other.taskId:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Office._t_DeliveryReceipt)

        __repr__ = __str__

    _M_Office._t_DeliveryReceipt = IcePy.defineStruct('::Office::DeliveryReceipt', DeliveryReceipt, (), (
        ('account', (), _M_Office._t_Account),
        ('taskId', (), IcePy._t_long)
    ))

    _M_Office.DeliveryReceipt = DeliveryReceipt
    del DeliveryReceipt

_M_Office._t_TaskProcessor = IcePy.defineValue('::Office::TaskProcessor', Ice.Value, -1, (), False, True, None, ())

if 'TaskProcessorPrx' not in _M_Office.__dict__:
    _M_Office.TaskProcessorPrx = Ice.createTempClass()
    class TaskProcessorPrx(Ice.ObjectPrx):

        def processTask(self, task, account, context=None):
            return _M_Office.TaskProcessor._op_processTask.invoke(self, ((task, account), context))

        def processTaskAsync(self, task, account, context=None):
            return _M_Office.TaskProcessor._op_processTask.invokeAsync(self, ((task, account), context))

        def begin_processTask(self, task, account, _response=None, _ex=None, _sent=None, context=None):
            return _M_Office.TaskProcessor._op_processTask.begin(self, ((task, account), _response, _ex, _sent, context))

        def end_processTask(self, _r):
            return _M_Office.TaskProcessor._op_processTask.end(self, _r)

        def sendDeliveryReceipt(self, deliveryReceipt, context=None):
            return _M_Office.TaskProcessor._op_sendDeliveryReceipt.invoke(self, ((deliveryReceipt, ), context))

        def sendDeliveryReceiptAsync(self, deliveryReceipt, context=None):
            return _M_Office.TaskProcessor._op_sendDeliveryReceipt.invokeAsync(self, ((deliveryReceipt, ), context))

        def begin_sendDeliveryReceipt(self, deliveryReceipt, _response=None, _ex=None, _sent=None, context=None):
            return _M_Office.TaskProcessor._op_sendDeliveryReceipt.begin(self, ((deliveryReceipt, ), _response, _ex, _sent, context))

        def end_sendDeliveryReceipt(self, _r):
            return _M_Office.TaskProcessor._op_sendDeliveryReceipt.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Office.TaskProcessorPrx.ice_checkedCast(proxy, '::Office::TaskProcessor', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Office.TaskProcessorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Office::TaskProcessor'
    _M_Office._t_TaskProcessorPrx = IcePy.defineProxy('::Office::TaskProcessor', TaskProcessorPrx)

    _M_Office.TaskProcessorPrx = TaskProcessorPrx
    del TaskProcessorPrx

    _M_Office.TaskProcessor = Ice.createTempClass()
    class TaskProcessor(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Office::TaskProcessor')

        def ice_id(self, current=None):
            return '::Office::TaskProcessor'

        @staticmethod
        def ice_staticId():
            return '::Office::TaskProcessor'

        def processTask(self, task, account, current=None):
            raise NotImplementedError("servant method 'processTask' not implemented")

        def sendDeliveryReceipt(self, deliveryReceipt, current=None):
            raise NotImplementedError("servant method 'sendDeliveryReceipt' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Office._t_TaskProcessorDisp)

        __repr__ = __str__

    _M_Office._t_TaskProcessorDisp = IcePy.defineClass('::Office::TaskProcessor', TaskProcessor, (), None, ())
    TaskProcessor._ice_type = _M_Office._t_TaskProcessorDisp

    TaskProcessor._op_processTask = IcePy.Operation('processTask', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Office._t_Task, False, 0), ((), _M_Office._t_Account, False, 0)), (), None, (_M_Office._t_TaskProccessingException,))
    TaskProcessor._op_sendDeliveryReceipt = IcePy.Operation('sendDeliveryReceipt', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Office._t_DeliveryReceipt, False, 0),), (), None, ())

    _M_Office.TaskProcessor = TaskProcessor
    del TaskProcessor

# End of module Office
